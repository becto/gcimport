#!/usr/bin/env python2
# -*- coding: utf-8 -*-
##
# gcimport
# author: notizblock <nblock@archlinux.us>
# license: GPLv3
'''Convert various banking statements to csv files that can be easily parsed with GnuCash.'''

import codecs
import argparse
import os
import re
from decimal import Decimal
from datetime import datetime

def __check_infile(infile):
    '''Check if infile exists and is readable.'''
    if not os.access(infile, os.R_OK):
        raise argparse.ArgumentTypeError(
                "'{0}' does not exist or is not readable.".format(infile))
    return infile

def __decimal_to_gc_amount(value):
    '''Add income and expenses keys according to key "amount".'''
    __convert = lambda x: '{:.2f}'.format(x).replace('.', ',')
    item = []
    if value <= 0:
        item.append(__convert(0))          #income
        item.append(__convert(abs(value))) #expense
    else:
        item.append(__convert(value))      #income
        item.append(__convert(0))          #expense
    return item

def detect_input_format(infile):
    '''Detect input format and select the function to parse the file.
    Raise a ValueError on unknown files.'''
    if infile.endswith('Herunterladen.csv'):
        return convert_paypal
    elif 'EASYBANK_Umsatzliste' in infile:
        return convert_easybank
    elif 'umsaetze-girokonto_' in infile:
        return convert_livebank
    elif 'elbi_umsaetze' in infile:
        return convert_elba
    else:
        raise ValueError('Could not detect input format.')

def read_infile(infile, encoding='utf-8'):
    '''Read from infile and return content as list of lines'''
    with codecs.open(infile, 'r', encoding=encoding) as f:
        return f.readlines()

def write_csv(outfile, data_list):
    '''Write data to csv file.'''
    #[{
    # 'date':datetime object,
    # 'description':'description',
    # 'income':'700,00',
    # 'expense': '0,00'
    #}, ...]
    with open(outfile, 'w') as f:
        for item in data_list:
            out_str = '"{}","{}","{}","{}"\n'.format(
                    item['date'].strftime(u'%Y.%m.%d'),
                    item['description'].encode('utf-8'),
                    item['income'].encode('utf-8'),
                    item['expense'].encode('utf-8')
                    )
            f.write(out_str)

def convert_elba(infile):
    '''Convert ELBA csv to internal format and return it.'''
    keys = (u'date', u'description', u'income', u'expense')
    data_list = []
    for line in read_infile(infile, encoding='cp1252'):
        parts = line.strip().split(';')[:-1]

        #delete unnecessary values
        for idx in (5, 4, 2):
            del(parts[idx])

        #parse date
        parts[0] = datetime.strptime(parts[0], '%d.%m.%Y')

        #convert string to decimal
        parts[2] = Decimal(parts[2].replace(',','.'))
        parts.extend(__decimal_to_gc_amount(parts[2]))
        del(parts[2])

        #remove " from description
        parts[1] = parts[1][1:-1]

        data_list.append(dict(zip(keys, parts)))

    return data_list

def convert_easybank(infile):
    '''Convert easybank csv to internal format and return it.'''
    keys = (u'description', u'date', u'income', u'expense')
    data_list = []
    reg_description = re.compile(r'[A-Z]{2}/[0-9]{9}')
    reg_iban = re.compile(r'([A-Z]{6}[A-Z0-9]{2}[^\s]*)\s([A-Z]{2}[0-9]{10,34}\s)(.*)')
    reg_legacy = re.compile(r'(.*)([0-9]{5,})\s([0-9]{6,})(.*)')

    def cleanup_description(desc):
        '''Cleanup up description based of account type.'''
        if '|' in desc: # most likely a cc account
            return description_from_cc(desc)
        else:
            return description_from_giro(desc)

    def description_from_giro(desc):
        '''Cleanup description from a giro account.'''
        # extract iban/bic, account number, ...
        extracted_data = {}
        done = False
        tmp = [x.strip() for x in reg_description.split(desc)]
        if tmp[1]:
            # extract iban, bic and text
            iban_bic = reg_iban.search(tmp[1])
            if iban_bic:
                extracted_data['nr'] = iban_bic.group(2).strip()
                extracted_data['bank'] = iban_bic.group(1)
                extracted_data['vendor'] = iban_bic.group(3)
                done = True
            # bank number
            if not done:
                account_number = reg_legacy.search(tmp[1])
                if account_number:
                    extracted_data['bank'] = account_number.group(2)
                    extracted_data['nr'] = account_number.group(3)
                    if account_number.group(1):
                        extracted_data['vendor'] = account_number.group(1).strip()
                    else:
                        extracted_data['vendor'] = account_number.group(4).strip()
                    done = True

        # build up description
        if not tmp[1]:
            return u'{0}'.format(tmp[0])
        elif not done:
            return u'{0}: {1}'.format(tmp[0], tmp[1])
        elif len(extracted_data) == 3:
            return u'{0}: {1} ({2} {3})'.format(
                    tmp[0], extracted_data['vendor'],
                    extracted_data['nr'], extracted_data['bank'])
        else:
            return None

    def description_from_cc(desc):
        '''Cleanup description from a cc account'''
        tmp = desc.split('|')
        if len(tmp) == 2:
            return u'{0} ({1})'.format(tmp[0], tmp[1])
        elif len(tmp) == 3:
            return u'{0} - {1} ({2})'.format(tmp[0], tmp[1], tmp[2])

    for line in read_infile(infile, encoding='cp1252'):
        parts = line.strip().split(';')

        #delete unnecessary values
        for idx in (5, 3, 0):
            del(parts[idx])

        #parse date
        parts[1] = datetime.strptime(parts[1], '%d.%m.%Y')

        # use cleaned description or fall back to default
        extracted_data = cleanup_description(parts[0])
        if extracted_data:
            parts[0] = extracted_data
        else:
            print('Could not cleanup description, using default.')

        #convert string to decimal
        parts[2] = parts[2].replace('.','')
        parts[2] = Decimal(parts[2].replace(',','.'))
        parts.extend(__decimal_to_gc_amount(parts[2]))
        del(parts[2])

        data_list.append(dict(zip(keys, parts)))

    return data_list

def convert_livebank(infile):
    '''Convert livebank csv to internal format and return it.'''
    keys = (u'date', u'description', u'income', u'expense')
    data_list = []
    for line in read_infile(infile, encoding='iso-8859-1')[1:]:
        parts = line.strip().split(';')

        # skip the enire record if there is no amount to account
        if parts[7] == "0,00":
            continue

        # delete unnecessary values
        for idx in (6, 5, 4, 2, 1, 0):
            del(parts[idx])

        # merge everything from the 2nd element
        parts[2] = ','.join(parts[2:]).replace('"', '')
        for idx in range(len(parts)-1, 2, -1):
            del(parts[idx])

        # parse date
        parts[0] = datetime.strptime(parts[0], '%Y-%m-%d')

        # convert string to decimal
        parts[1] = parts[1].replace('.','')
        parts[1] = Decimal(parts[1].replace(',','.'))
        parts.extend(__decimal_to_gc_amount(parts[1]))
        del(parts[1])

        data_list.append(dict(zip(keys, parts)))

    return data_list

def convert_paypal(infile):
    '''Convert paypal csv files to internal format and return it.'''
    keys = (u'date', u'description', u'income', u'expense')
    data_list = []
    for line in read_infile(infile, encoding='iso-8859-1')[1:]: #skip first line
        parts = line.strip().split('"')
        parts = [part for part in parts if part]
        parts = [part for part in parts if len(part) != 1]

        #delete unnecessary values
        for idx in (8, 6, 5, 4, 2, 1):
            del(parts[idx])

        #parse date
        parts[0] = datetime.strptime(parts[0], '%d.%m.%Y')

        ##convert string to decimal
        parts[2] = Decimal(parts[2].replace(',','.'))
        parts.extend(__decimal_to_gc_amount(parts[2]))
        del(parts[2])

        data_list.append(dict(zip(keys, parts)))

    return data_list

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('infile', help='The input file to convert.', type=__check_infile)
    parser.add_argument('outfile', help='The GnuCash compatible csv file to write.', type=str)
    args = parser.parse_args()

    try:
        func = detect_input_format(args.infile)
        data = func(args.infile)
        write_csv(args.outfile, data)
    except ValueError as e:
        print(e)
