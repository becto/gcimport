#!/usr/bin/env python2
# -*- coding: utf-8 -*-
##
# gcimport
# author: notizblock <nblock@archlinux.us>
# license: GPLv3
'''Convert various input files (csv, txt) to csv files that can be easily parsed with GnuCash.'''

import codecs
import argparse
import os
from decimal import Decimal
from datetime import datetime

def __check_infile(infile):
    '''Check if infile exists and is readable.'''
    if not os.access(infile, os.R_OK):
        raise argparse.ArgumentTypeError(
                "'{0}' does not exist or is not readable.".format(infile))
    return infile

def __decimal_to_gc_amount(value):
    '''Add income and expenses keys according to key "amount".'''
    __convert = lambda x: '{:.2f}'.format(x).replace('.', ',')
    item = []
    if value <= 0:
        item.append(__convert(0))          #income
        item.append(__convert(abs(value))) #expense
    else:
        item.append(__convert(value))      #income
        item.append(__convert(0))          #expense
    return item

def detect_input_format(infile):
    '''Detect input format and select the function to parse the file.
    Raise a ValueError on unknown files.'''
    if infile.endswith('Herunterladen.csv'):
        return convert_paypal
    elif infile.endswith('notes.txt') or infile.endswith('.eml'):
        return convert_notes
    elif infile.endswith('EASYBANK_Umsatzliste.csv'):
        return convert_easybank
    elif 'elbi_umsaetze' in infile:
        return convert_elba
    else:
        raise ValueError('Could not detect input format.')

def read_infile(infile, encoding='utf-8'):
    '''Read from infile and return content as list of lines'''
    with codecs.open(infile, 'r', encoding=encoding) as f:
        return f.readlines()

def write_csv(outfile, data_list):
    '''Write data to csv file.'''
    #[{
    # 'date':datetime object, 
    # 'description':'description',
    # 'income':'700,00',
    # 'expense': '0,00'
    #}, ...]
    with open(outfile, 'w') as f:
        for item in data_list:
            out_str = '"{}","{}","{}","{}"\n'.format(
                    item['date'].strftime(u'%Y.%m.%d'),
                    item['description'].encode('utf-8'),
                    item['income'].encode('utf-8'),
                    item['expense'].encode('utf-8')
                    )
            f.write(out_str)

def convert_elba(infile):
    '''Convert ELBA csv to internal format and return it.'''
    keys = (u'date', u'description', u'income', u'expense')
    data_list = []
    for line in read_infile(infile, encoding='cp1252'):
        parts = line.strip().split(';')[:-1]

        #delete unnecessary values
        for idx in (5, 4, 2):
            del(parts[idx])

        #parse date
        parts[0] = datetime.strptime(parts[0], '%d.%m.%Y')

        #convert string to decimal
        parts[2] = Decimal(parts[2].replace(',','.'))
        parts.extend(__decimal_to_gc_amount(parts[2]))
        del(parts[2])

        #remove " from description
        parts[1] = parts[1][1:-1]

        data_list.append(dict(zip(keys, parts)))

    return data_list

def convert_easybank(infile):
    '''Convert easybank csv to internal format and return it.'''
    keys = (u'description', u'date', u'income', u'expense')
    data_list = []
    for line in read_infile(infile, encoding='cp1252'):
        parts = line.strip().split(';')

        #delete unnecessary values
        for idx in (5, 3, 0):
            del(parts[idx])

        #parse date
        parts[1] = datetime.strptime(parts[1], '%d.%m.%Y')

        #convert string to decimal
        parts[2] = parts[2].replace('.','')
        parts[2] = Decimal(parts[2].replace(',','.'))
        parts.extend(__decimal_to_gc_amount(parts[2]))
        del(parts[2])

        data_list.append(dict(zip(keys, parts)))

    return data_list

def convert_notes(infile):
    '''Convert NoteMe notes to internal format and return it.'''
    keys = (u'date', u'description', u'income', u'expense')

    input_lines = read_infile(infile)
    if infile.endswith('.eml'):
        bn = os.path.basename(infile).decode('utf8')
        start_idx = input_lines.index(u'[{}]\r\n'.format(bn[:-len('.eml')]))+2
        stop_idx = input_lines.index(u'-- \r\n', start_idx)
        del input_lines[stop_idx:]
        del input_lines[:start_idx]

    data_list = []
    for line in input_lines:
        parts = line.strip().split(' ')
        #join descriptions with spaces
        if len(parts) > 3:
            parts = [parts[0], parts[1], ' '.join(parts[2:])]

        #skip possibly invalid parts
        if len(parts) != 3 or len(parts[0]) != 6:
            continue

        #parse date and add current year
        parts[0] = datetime.strptime(parts[0], '%d.%m.')
        parts[0] = parts[0].replace(year=datetime.now().year)

        #prepare amount
        parts[1] = Decimal(parts[1])*-1
        parts.extend(__decimal_to_gc_amount(parts[1]))
        del(parts[1])

        data_list.append(dict(zip(keys, parts)))

    return data_list

def convert_paypal(infile):
    '''Convert paypal csv files to internal format and return it.'''
    keys = (u'date', u'description', u'income', u'expense')
    data_list = []
    for line in read_infile(infile, encoding='iso-8859-1')[1:]: #skip first line
        parts = line.strip().split('"')
        parts = [part for part in parts if part]
        parts = [part for part in parts if len(part) != 1]

        #delete unnecessary values
        for idx in (8, 6, 5, 4, 2, 1):
            del(parts[idx])

        #parse date
        parts[0] = datetime.strptime(parts[0], '%d.%m.%Y')

        ##convert string to decimal
        parts[2] = Decimal(parts[2].replace(',','.'))
        parts.extend(__decimal_to_gc_amount(parts[2]))
        del(parts[2])

        data_list.append(dict(zip(keys, parts)))

    return data_list

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('infile', help='The input file to convert.', type=__check_infile)
    parser.add_argument('outfile', help='The GnuCash compatible csv file to write.', type=str)
    args = parser.parse_args()

    try:
        func = detect_input_format(args.infile)
        data = func(args.infile)
        write_csv(args.outfile, data)
    except ValueError as e:
        print(e)
